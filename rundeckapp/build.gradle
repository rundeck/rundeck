import java.io.File;
import java.util.Map;

import org.gradle.api.Project;
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

/**
 * The Rundeck webapp build file
 * 
 * It's important to note that grails has it's own build system based on Gant. Rather
 * than trying to integrate Gradle directly with Gant or use one of the Gradle-Grails plugins
 * available, we're following in the steps of the Make based build and just wrapping 
 * around the Grails builds.
 */

description = 'The Rundeck Grails webapp project'

apply plugin: 'groovy'
apply plugin: 'eclipse'

// set the convention to rundeck:<branch>:<path>:<projectName>
eclipse.project.name =  "${project.getParent().eclipse.project.name}:webapp"

// Properties for downloading & installing Grails
def grailsBaseName = "grails-${grailsVersion}"
def grailsZipFile = "${grailsBaseName}.zip"
def grailsZipFileLocation = "${rootProject.buildDir}/tmp/${grailsZipFile}"
def grailsInstallLocation = "${rootProject.buildDir}/local"
def grailsDownloadUrl = "http://dist.springframework.org.s3.amazonaws.com/release/GRAILS/grails-${grailsVersion}.zip"
def grailsHome = "${grailsInstallLocation}/${grailsBaseName}"
def graislCommandLine = "${grailsHome}/bin/grails"
def warFileLocation = "${project(':rundeckapp').projectDir}/target/rundeck-${version}.war"

/**
 * Downloads Grails from the SpringSource archives
 */
task downloadGrails {
	outputs.file file(grailsZipFileLocation);
	doLast {
		logger.warn("Downloading ${grailsBaseName}...")
		file("${rootProject.buildDir}/tmp/").mkdirs();
		ant.get(src: grailsDownloadUrl, dest: grailsZipFileLocation, verbose: true);
	}
}

/**
 * Expand the downloaded archive if it hasn't already been expanded
 */
task extractGrails(dependsOn: downloadGrails) {
	
	logger.debug("grailsZipFileLocation: ${grailsZipFileLocation}")
	inputs.file file(grailsZipFileLocation);
	
	logger.debug("grailsInstallLocation: ${grailsInstallLocation}")
	outputs.dir file(grailsInstallLocation);
	
	doLast {
		logger.info("Extracting ${grailsZipFile}...")
		file(grailsInstallLocation).mkdirs();
		copy {
			from zipTree(grailsZipFileLocation);
			into file(grailsInstallLocation);
		}
		// make sure that everything but the .bat files are set +x on linux / macs
		if (System.getProperty('os.name').toLowerCase().indexOf('win') < 0) {
			FileTree tree = fileTree("${grailsInstallLocation}/${grailsBaseName}/bin").exclude('**/*.bat');
			tree.each { File file ->
				logger.info('Setting +x permission on ' + file);
				file.setExecutable(true);
			}
		}
	}
}

/**
 * The Grails webapp has both compile and runtime dependencies on "core" and 
 * "rundeck-jetty-server" respectively - this task acts as a container for those 
 * dependencies so they are built and installed into the local ~/.m2 repo before 
 * we attempt to do anything further with Grails. 
 * 
 * TODO: this feels a bit circular? jetty-server --> webapp --> jetty-server?
 */
task installDependencies(dependsOn: [project(":core").install, project(":rundeck-launcher:rundeck-jetty-server").install]) << {
	description = "Builds and installs dependencies on other subprojects"
}

/**
 * Installs the jetty-plugin into the .grails folder
 */
task installJettyPlugin(type: Exec, dependsOn: [extractGrails, installDependencies]) {

	def jettyPluginZip = "${rootDir}/dependencies/grails-jetty/zips/grails-jetty-1.2-SNAPSHOT.zip"
	def jettyPluginInstalled = "${System.properties['user.home']}/.grails/${grailsVersion}/projects/rundeckapp/plugins/jetty-1.2-SNAPSHOT"
	
	inputs.source file(jettyPluginZip)
	outputs.dir file(jettyPluginInstalled)
	
	workingDir project(':rundeckapp').projectDir
	environment 'GRAILS_HOME', grailsHome
	commandLine graislCommandLine
	args 'install-plugin', jettyPluginZip
}

task cleanWar(type: Delete) {
	delete file(warFileLocation)
}

task clean(overwrite: true, dependsOn: cleanWar) {
	// noop clean - just chains cleanWar
}

/**
 * Wrapper task for grails test-app
 */
task test(type: Exec, overwrite: true, 
		dependsOn: [installJettyPlugin,
			project(":core").install, 
			project(":plugins:script-plugin").install, 
			project(":plugins:stub-plugin").install]) {
			
	workingDir project(':rundeckapp').projectDir
	environment 'GRAILS_HOME', grailsHome
	commandLine graislCommandLine
	args 'test-app','-coverage','-xml'
}

/**
 * Sets the value of app.version under application.properties
 */
task replaceVersion(type: PropertyValueUpdater) {
	propertyFile = file("${projectDir.path}/application.properties")
	propertiesMap = [ 'app.version' : project.version ]
}
			
/**
 * Builds the rundeck war file
 */
task war(type: Exec, dependsOn: [replaceVersion, test]) {
	inputs.sourceDir file("${projectDir}/src")
	outputs.file file(warFileLocation)
	workingDir project(':rundeckapp').projectDir
	environment 'GRAILS_HOME', grailsHome
	commandLine graislCommandLine
	args 'prod','war'
}

task build(overwrite: true, dependsOn: [test, war]) {
	// noop build because this isn't actually a java project 
	// besides the war task is handling building by issuing a "grails war" 
}

/**
 * Installs the war file into the ~/.m2 maven repo 
 */
task install(type: Exec, overwrite: true, dependsOn: build) {
	inputs.file file(warFileLocation)
	workingDir project(':rundeckapp').projectDir
	commandLine graislCommandLine
	args 'maven-install'
}

/**
 * Does an "in-place" substitution of a property value without having to using placeholders
 * 
 * @author jburbridge
 */
class PropertyValueUpdater extends DefaultTask {

	@OutputFile
	File propertyFile
	
	@Input
	Map propertiesMap
	
	@TaskAction
	def void replaceContents() {
		
		if (propertyFile.isFile() && propertyFile.exists()) {
			
			def newLines = []
			propertyFile.readLines().each { line ->
				
				logger.debug("${this} processing line: ${line}")
				// match the key and the value, but skip comments 
				def matcher = line =~ /^#{0}\s*([\w\.].*)\s*\=\s*(.*)$/
				// if there's a match and we have a property value, replace it 
				if (matcher.size() != 0 && matcher[0] != null && matcher[0].size() > 1) {
					newLines.add((propertiesMap[matcher[0][1]] != null) ?
						"${matcher[0][1]}=${propertiesMap[matcher[0][1]]}" : line)
				// if we don't find a match, just add the line back as-is
				} else {
					newLines.add(line)
				}
			}
			
			propertyFile.write(newLines.join("\n"))
			logger.warn("Wrote file: ${propertyFile}")
			
		} else {
			throw new TaskExecutionException(this, new RuntimeException("Could not find property file ${propertyFile}!"))
		}
	}
}

