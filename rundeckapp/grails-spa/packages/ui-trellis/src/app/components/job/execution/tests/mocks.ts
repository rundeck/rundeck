export const pluginsInitialData = [
  {
    description:
      "Export a JSON file from a template for retrieval via API.\n\nDefine a JSON template which will have context variable references expanded into a JSON data file, which can be later \ndownloaded or retrieved via API for further processing.\n",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: { faicon: "file" },
    name: "result-data-json-template",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: '{"export":{"value":"${data.value}"}}',
        description:
          'Define JSON data to export.\nEnter a valid JSON document. You can substitute context data values like `${data.name}` or `${data.value@nodename}`\n. Note that \nContext Variable expansion is evaluated in a global context, meaning that `${data.name}` will only work if there is \na global value matching that group and name.\nIf you want to include data captured from Node steps, such as when using the Key Value Data Log Filter, you can use a\n syntax like `${data.name*}` which will\ncollect all values for `data.name` in all Node contexts separated with a comma.\n\nYou can expand all node values like that into a JSON array using a special syntax:\n\n```json\n{ "key": [], "key@": "data.name" }\n```\n\nThis declares a map entry `key` as an array, and the `key@` declares will collect all Node entries for `data.name` \ninto the `key` value.\n\nThe result will be:\n\n```json\n{ "key": ["nodevalue1","nodevalue2"] }\n```\n\nIf you want the data expanded as a JSON Object instead, using Node Names as the map entries, declare the `key` entry \nas a JSON object:\n\n```json\n{ "key" : {}, "key@": "data.name" }\n```\n\nThe result will be:\n\n```json\n{ "key" : {"node1": "nodevalue1", "node2": "nodevalue2" } }\n```\n\nYou can select a subset of node values using a syntax after the `@` sign in the key:\n\n* `key@~REGEX` matches all nodes matching the regular expression\n\nSimilarly for Step values, you can select values based on the step key using this syntax:\n\n* `*:key` matches all steps\n* `1:key` only step 1 value\n\n```json\n{ "key" : [], "*:key": "data.name" }\n```\n\nResults in `key` value being an array of all Step data values for `data.name`.\n\nA combination of `*:key@` will enumerate all step and node values if there are different values in different steps.\n\nA value of `1:key@` will match all node values in step 1.\n\nNote that if you the value from a single node, you can use the normal variable expansion such as\n`${data.name@nodename}` (value for node `nodename`) or `${1:data.name}` (step value for step 1).\n',
        name: "jsonTemplate",
        renderingOptions: { displayType: "CODE", codeSyntaxMode: "json" },
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "JSON Template",
        type: "String",
        validator: null,
      },
    ],
    propertiesMapping: {},
    title: "Result Data / JSON Template",
  },
  {
    description:
      "Store arbitrary key values pairs against your job to help understand your ROI (return on investment) per job execution.\n\n\n\nBelow, define the keys and values that you want to track per job. The metrics will be stored against the job,\n and accessible via API for further analysis, as well as available in the results of the job execution. We also\n add in relevant execution data to help you further understand your savings. Access is always available at\n  `api/{apiVersion}/execution/{execId}/roimetrics/data`.\n",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: { faicon: "coins" },
    name: "roi-metrics",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description:
          "Use 'Add Custom Field' to add a new key for tracking. The 'key' field is what will be added to\n the ROI metrics data. The 'label' and 'description' fields create a friendly name and additional details for the\n  Rundeck UI. Once added, you can manage the value in this UI. The custom field keys and values are added to the\n data payload and presented to the user at the end of each job.\n",
        name: "userRoiData",
        renderingOptions: { displayType: "DYNAMIC_FORM" },
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "ROI Metrics Fields",
        type: "String",
        validator: null,
      },
    ],
    propertiesMapping: {},
    title: "ROI Metrics Data",
  },
  {
    description:
      'Allow resuming this job if one or more steps fail. (See Caveats). \n\n\nRecords the workflow state if one or more steps fail, allowing a new Execution to be\ncreated which resumes the workflow from right before the failed step(s).\n\n## Caveats - Workflow Strategies\n\nDoes not work with "Node First" workflow strategy.\n\nOnly works with these workflow strategies:\n\n* Sequential\n* Parallel\n* Ruleset\n\n## Caveats - Secure Options\n\nThe runtime values for "Secure" or "Secure Remote Authentication" options **will not** be \npersisted with the Resumable workflow state.  \n\nThis means that Secure Option values will only be available when Resuming a job in these cases:\n\n* If a secure option defines a Storage Path, the Key Storage value will be loaded when the execution is Resumed.\n* If "Other > Retry" is configured for the Job, and "Resume On Retry" is checked, secure option values will be available when the execution is automatically retried.\n\nIn other words, manually-entered Secure Option values will not be available when a manual "Resume" action is performed.  \n\n',
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: { faicon: "angle-double-right" },
    name: "resume",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description:
          "If Retries are enabled, will automatically resume beginning at the failed step",
        name: "onRetry",
        renderingOptions: {},
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Resume On Retry",
        type: "Boolean",
        validator: {},
      },
      {
        blankIfUnexpandable: true,
        defaultValue: "60000",
        description:
          "Time in Milliseconds to wait while loading remote resume state data if necessary \n(default: 60000)",
        name: "timeout",
        renderingOptions: {},
        required: false,
        scope: "Project",
        selectLabels: null,
        selectValues: null,
        title: "State Loading Timeout",
        type: "Long",
        validator: {},
      },
    ],
    propertiesMapping: {},
    title: "Resumable",
  },
  {
    description:
      "Kill all processes collected by the 'Capture Process IDs' log filter\n\n\nThis operation will use the 'kill' and 'pkill' for Unix and 'taskkill' for Windows commands. These commands must be available at the node.\n",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: {},
    name: "killhandler",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description:
          "Also kill processes whose process SID matches the tracked PIDs",
        name: "killChilds",
        renderingOptions: {},
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Kill spawned processes",
        type: "Boolean",
        validator: {},
      },
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description: "Kill processes only if job failed or is killed",
        name: "onFailOnly",
        renderingOptions: {},
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Kill only on job failure",
        type: "Boolean",
        validator: {},
      },
    ],
    propertiesMapping: {},
    title: "Kill tracked processes after execution",
  },
  {
    description:
      "Export context data captured in the Execution for retrieval via API.\n\nData context variables in the specified groups are stored in a JSON data file, which can be later \ndownloaded or retrieved via API for further processing.",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: { faicon: "file" },
    name: "result-data-export-context",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: "export",
        description:
          'Set of global data context groups to export.\nYou can choose all groups by using `*`, or specific group names using a comma-separated list like `export,data`.\n\nNote that this *only* exports Global context data.  If you capture date in a Node Step such as a Command or Script step,\nyou must first "Export" that to the Global context using the **Global Variable** Workflow Step.\n\nExample:\n\n1. Capture a step value using the Key Value Data Log Filter plugin on a Command step, called `data.myvalue`\n2. (The value is now stored at the Node context for the Node(s) that the step was executed on.)\n3. Use a Global Variable workflow step to export it, set Value: `${data.myvalue*}` Group: `export`, Name: `myvalue` .\n\nNow using this plugin you can export all values in the `export` group to JSON. \n',
        name: "groups",
        renderingOptions: { displayType: "SINGLE_LINE" },
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Data Groups",
        type: "String",
        validator: null,
      },
    ],
    propertiesMapping: {},
    title: "Result Data / Export Context Data",
  },
  {
    description: "Refresh healthcheck cache before job execution starts",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: {},
    name: "refreshHealthCheckerCache",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: "false",
        description:
          "If enabled, force healthcheck cache to refresh before job execution starts.",
        name: "enabled",
        renderingOptions: {},
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Enabled",
        type: "Boolean",
        validator: {},
      },
    ],
    propertiesMapping: {},
    title: "Refresh HealthChecker cache",
  },
  {
    description: "Retry execution just on failed nodes.",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: {},
    name: "Retry-Failed-Nodes",
    order: 0,
    pluginGroupType: null,
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: "false",
        description: "If enabled, retry will just run failed nodes.",
        name: "enabled",
        renderingOptions: {},
        required: false,
        scope: "Unspecified",
        selectLabels: null,
        selectValues: null,
        title: "Enabled",
        type: "Boolean",
        validator: {},
      },
    ],
    propertiesMapping: {},
    title: "Job Retry Failed Nodes",
  },
  {
    description:
      "If enabled, all Incident Output captured during a job will be sent to PagerDuty Incident Response.",
    fwkPropertiesMapping: {},
    highlighted: false,
    metadata: {},
    name: "Send Incident Output to Pagerduty",
    order: 0,
    pluginGroupType: "com.rundeck.plugins.pagerduty.PagerdutyPluginGroup",
    properties: [
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description: "Outbound proxy host",
        name: "proxy_host",
        renderingOptions: { displayType: "SINGLE_LINE" },
        required: false,
        scope: "Project",
        selectLabels: null,
        selectValues: null,
        title: "Proxy host",
        type: "String",
        validator: null,
      },
      {
        blankIfUnexpandable: true,
        defaultValue: null,
        description: "Outbound proxy port",
        name: "proxy_port",
        renderingOptions: {},
        required: false,
        scope: "Project",
        selectLabels: null,
        selectValues: null,
        title: "Proxy port",
        type: "Integer",
        validator: {},
      },
    ],
    propertiesMapping: {},
    title: "Send Incident Output to PagerDuty",
  },
];

export const executionLifecycle = {
  resume: { onRetry: "true", timeout: "60000" },
  "result-data-json-template": {
    jsonTemplate:
      '{\n  "export": {\n    "value": "${data.value}",\n    "anothervalue": "123"\n  }\n}',
  },
  killhandler: { killChilds: "true", onFailOnly: "true" },
  refreshHealthCheckerCache: { enabled: "true" },
  "Retry-Failed-Nodes": { enabled: "true" },
  "Send Incident Output to Pagerduty": {},
  "roi-metrics": {
    userRoiData:
      '[{"key":"field_key","label":"field_label","value":"field_value","desc":"Field key field_key"}]',
  },
  "result-data-export-context": { groups: "export" },
};
